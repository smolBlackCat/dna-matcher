"""Module that provides some widgets and functions to deal with the
game interface.
"""

import textwrap

import pygame.constants as constants
import pygame.font as font
import pygame.mouse as mouse
import pygame.sprite as sprite
import pygame.surface as surface


class Button(sprite.Sprite):
    """This class represents a interface button on a game. The button can have
    any look, as it has the off and on variants.
    """

    def __init__(self, screen, button_on_image, button_off_image,
                 button_clicked_image, action=None):
        """Initialises the Button object.

        Args:
            screen:
                A pygame Surface object that represents the screen.

            button_on_image:
                The loaded sprite of the button when the mouse is
                above the button.

            button_off_image:
                The loaded sprite of the button when the mouse is not
                above the button.

            button_clicked_image:
                The loaded sprite of the button when the mouse clicks
                the button.

            action:
                A function that is always executed when the button is
                pressed.
        """

        self.screen = screen
        self.button_on_image = button_on_image
        self.button_off_image = button_off_image
        self.button_clicked_image = button_clicked_image
        self.current_sprite = button_off_image
        self.rect = self.current_sprite.get_rect()
        self.action = action

    def draw(self):
        """Draws the button on the screen."""

        self.screen.blit(self.current_sprite, self.rect)
    
    def update_on_event(self, event):
        if event.type == constants.MOUSEBUTTONUP:
            if self.rect.collidepoint(event.pos) and event.button == 1:
                self.current_sprite = self.button_off_image
                if self.action is not None:
                    self.action()

    def update(self):
        """Updates the button according to the user actions.

        User actions == Hover the mouse on the button, Click the
        button and etc.
        """

        if self.rect.collidepoint(mouse.get_pos()):
            self.current_sprite = self.button_on_image
            if mouse.get_pressed()[0]:
                self.current_sprite = self.button_clicked_image
        else:
            self.current_sprite = self.button_off_image


class Label(sprite.Sprite):
    """Class that represents a label on a game."""

    def __init__(self, screen, image, animation=None, *animation_args):
        """Initialises the Label object.

        Args:
            screen:
                A Surface object representing the game window.

            image:
                May be a loaded image or a generated by pygame, like
                texts.

            animation:
                A function that executes the animation, like a
                floating object.
        """

        self.screen = screen
        self.image = image
        self.animation = animation
        self.animation_args = list(animation_args)
        self.rect = image.get_rect()

        self.yspeed = 3

    def draw(self):
        """Draws the label on the screen."""

        self.screen.blit(self.image, self.rect)

    def update(self):
        """Updates the label on the screen."""

        if self.animation is not None:
            args = [self] + self.animation_args
            self.animation(*args)

    def update_text(self, new_text):
        """It updates the text, therefore updating the surface.
        
        Important to mention that the new surface, will use the
        already defined attributes, like colour and size.

        Args:

            new_text:
                The new text rendered in the image attribute.
        """

        self.image = generate_text_surface(
            new_text, self.colour,self.size, self.chars_per_line,
            self.y_padding, self.bold, self.italic, self.antialised)
        self.rect = self.image.get_rect()

    @classmethod
    def from_text(cls, screen, text, colour, size, chars_per_line, y_padding,
                  bold=False, italic=False, antialised=False):
        """Creates a label object based on a text.

        Args:

            text:
                str object containing the text to be generated for
                this label.

            size:
                The character size.

            chars_per_line:
                the amount of characters in each line.

            bold:
                Optional arg where determines if the text is bold or
                not.

            italic:
                Optional arg where determines if the text is italic
                or not.
        
        Returns:
            A Label object that it works as a plain text.
        """

        text_bg = generate_text_surface(text, colour, size, chars_per_line,
                                        y_padding, bold, italic, antialised)

        text_label = cls(screen, text_bg)

        text_label.colour = colour
        text_label.size = size
        text_label.chars_per_line = chars_per_line
        text_label.y_padding = y_padding
        text_label.bold = bold
        text_label.italic = italic
        text_label.antialised = antialised

        return text_label


def generate_text_surface(text, colour, size, chars_per_line, y_padding,
                          bold=False, italic=False, antialised=False):
    """Generates a Surface object that contains a wrapped text.

    Args:
    
        text:
            The text to be created on the surface.
        
        colour:
            The text colour
        
        chars_per_line:
            The amount of characters in each line.
        
        y_padding:
            The amount of vertical padding from line to line.
        
        bold:
            Indicates if the text is bold.
        
        italic:
            Indicates if the text is italic.
        
        antialised:
            Indicates if the text in the surface is antialised.
    
    Returns:
        A Surface object with a blitted Surface object that is in
        fact the rendered text.
    """

    text_font = font.SysFont(None, size, bold, italic)
    rendered_paragraph = [
        text_font.render(phrase, antialised, colour)
        for phrase in textwrap.wrap(text, chars_per_line)
    ]

    height = sum(
        [phrase.get_height() + y_padding for phrase in rendered_paragraph]
    )
    width = max([phrase.get_width() for phrase in rendered_paragraph])
    text_bg = surface.Surface((width, height), constants.SRCALPHA)

    row = 0
    for phrase in rendered_paragraph:
        rect = phrase.get_rect()
        rect.y = row
        text_bg.blit(phrase, rect)
        row += text_font.get_height() + y_padding

    return text_bg
